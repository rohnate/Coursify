- You do NOT clone when you already have a local project.
    You add the remote instead.
        Cloning is only for empty folders.
    If the remote repo on git has some files, then you have to pull them first.

- dotenv is loaded once, in the main file only then can called anywhere. npm install dotenv


Q - What is Router in Express ?

Ans - Imagine you put all routes in `index.js`:

        ```js
        app.get("/login", ...)
        app.post("/signup", ...)
        app.get("/courses", ...)
        app.post("/courses", ...)
        app.delete("/courses/:id", ...)
        ```

        ðŸ˜µ File becomes huge and messy.

        ðŸ‘‰ Router helps you split routes into small files.

        ---

        ## What is a router? (simple definition)

        > A router is like a mini Express app that handles routes for a specific feature.

        Think:

        * `app` â†’ whole application
        * `router` â†’ one section (users, courses, auth)

        ---

        ## Basic router example

        `routes/user.routes.js`

        ```js
        const express = require("express");
        const router = express.Router();

        router.post("/signup", (req, res) => {
        res.send("User signup");
        });

        router.post("/login", (req, res) => {
        res.send("User login");
        });

        module.exports = router;
        ```

        ---

        ## Using router in main file

        `index.js`

        ```js
        const express = require("express");
        const app = express();

        const userRouter = require("./routes/user.routes");

        app.use("/users", userRouter);

        app.listen(3000);
        ```

        ---

        ## How URLs are formed (important!)

        ```js
        app.use("/users", userRouter);
        ```

        Inside router:

        ```js
        router.post("/login", ...)
        ```

        âž¡ Final URL:

        ```
        POST /users/login
        ```

        ---

        ## Why router is IMPORTANT (big reasons)

        1ï¸âƒ£ Clean code

        Each feature has its own file.

        2ï¸âƒ£ Easy to scale

        Add new routes without touching main file.

        3ï¸âƒ£ Team-friendly

        Multiple devs can work on different routers.

        4ï¸âƒ£ Middleware support

        You can add middleware to router only.

        ---

        ## Router with middleware (very useful)

        ```js
        router.use(authMiddleware);

        router.get("/profile", (req, res) => {
        res.send("Protected profile");
        });
        ```

        Only this router is protected ðŸ”

        ---

        ## Folder structure (recommended)

        ```
        src
        â”œâ”€â”€ index.js
        â”œâ”€â”€ routes
        â”‚   â”œâ”€â”€ user.routes.js
        â”‚   â”œâ”€â”€ course.routes.js
        â”‚   â””â”€â”€ admin.routes.js
        â”œâ”€â”€ controllers
        â””â”€â”€ models
        ```
        - It just connects URL â†’ logic.

Q - Can we use Zod input validation inside the mongoose schema itself ?

Ans - You do NOT use Zod inside database schemas (like Mongoose schemas).   

    Zod is used for request validation,
    Mongoose schema is used for database structure.

    They solve different problems.

    ---

    ## Think of it like this ðŸ§ 

    1ï¸âƒ£ Zod â†’ â€œIs the incoming data valid?â€

    * Runs before data reaches DB
    * Validates request body, params, query

    2ï¸âƒ£ Mongoose Schema â†’ â€œHow is data stored?â€

    * Defines MongoDB structure
    * Enforces DB-level rules

    ðŸ‘‰ They should not be mixed.

    ---

    ## Correct and CLEAN architecture âœ…

    ```
    request
    â†“
    Zod (validate input)
    â†“
    Controller
    â†“
    Mongoose Schema (save to DB)
    ```

    ---

    ## How to use Zod properly (BEST PRACTICE)

    Step 1: Create Zod schema (validation)

    ```js
    // validators/course.zod.js
    const { z } = require("zod");

    const createCourseSchema = z.object({
    title: z.string().min(3),
    price: z.number().positive(),
    description: z.string().optional(),
    });

    module.exports = { createCourseSchema };
    ```

    ---

    Step 2: Use Zod in route or controller

    ```js
    const { createCourseSchema } = require("../validators/course.zod");

    router.post("/courses", (req, res) => {
    const parsed = createCourseSchema.safeParse(req.body);

    if (!parsed.success) {
        return res.status(400).json(parsed.error);
    }

    // parsed.data is clean & validated
    });
    ```

    ---

    ## âŒ What you should NOT do

    ```js
    const courseSchema = new mongoose.Schema({
    title: z.string(),   // âŒ WRONG
    });
    ```

    Zod does not work here.

    ---

    ## Advanced (optional, for later)

    You can:

    * Share types between Zod & Mongoose
    * Generate TS types from Zod
    * Keep Zod as the single source of truth

    But for now â†’ keep them separate.

    ---

    ## Golden rule (remember this forever)

    > Zod validates requests
    > Mongoose defines database structure

Q - What are controllers ? and what problem do controllers solve?

Ans - Without controllers, people write code like this in routes:

        ```js
        router.post("/courses", async (req, res) => {
        // validate
        // auth check
        // db logic
        // response
        });
        ```

        After some time:

        * routes become huge
        * logic is duplicated
        * code is hard to read & test

        ðŸ‘‰ Controllers fix this.

        ---

        ðŸ”´ What is a controller? (simple definition)

        > A controller is a function that contains the actual business logic
        > Routes only decide which URL calls which controller

        ---

        ## One-line summary ðŸ§ 

        * Route = address
        * Controller = work done at that address

        ---

        ## Very simple example

        âŒ Without controller

        ```js
        router.post("/login", async (req, res) => {
        const user = await User.findOne({ email: req.body.email });
        res.json(user);
        });
        ```

        ---

        âœ… With controller

        # controller

        ```js
        // controllers/user.controller.js
        async function login(req, res) {
        const user = await User.findOne({ email: req.body.email });
        res.json(user);
        }

        module.exports = { login };
        ```

        # route

        ```js
        // routes/user.routes.js
        const { login } = require("../controllers/user.controller");

        router.post("/login", login);
        ```

        Clean âœ¨

        ---

        ## Why controllers are IMPORTANT

        1ï¸âƒ£ Clean routes

        Routes only map URLs â†’ controllers.

        2ï¸âƒ£ Reusable logic

        Same controller can be used by multiple routes.

        3ï¸âƒ£ Easy testing

        You can test controller logic independently.

        4ï¸âƒ£ Real-world standard

        Almost all production apps use controllers.

        ---

        ## Where controllers sit (structure)

        ```
        src
        â”œâ”€â”€ routes
        â”‚   â””â”€â”€ course.routes.js
        â”œâ”€â”€ controllers
        â”‚   â””â”€â”€ course.controller.js
        â”œâ”€â”€ models
        â”œâ”€â”€ middlewares
        ```

        ---

        ## Real example (course controller)

        # controller

        ```js
        // controllers/course.controller.js
        const Course = require("../models/course.model");

        async function createCourse(req, res) {
        const course = await Course.create({
            title: req.body.title,
            price: req.body.price,
            creator: req.user._id,
        });

        res.status(201).json(course);
        }

        module.exports = { createCourse };
        ```

        ---

        # route

        ```js
        router.post("/courses", auth, role("admin"), createCourse);
        ```

        ---

        ## What controllers should NOT do âŒ

        * âŒ define routes
        * âŒ connect DB
        * âŒ handle auth directly

        ---

        ## What controllers SHOULD do âœ…

        * handle request
        * talk to DB
        * apply business rules
        * send response

        ---

        ## Mental flow (remember this)

        ```
        Request
        â†’ Middleware
        â†’ Controller
        â†’ Model
        â†’ Response
        ```

        ---

        ## Beginner-friendly rule

        > If logic is more than 3â€“4 lines â†’ put it in a controller

        ---

- Request
    â†’ Middleware
    â†’ Controller
    â†’ Model
    â†’ Response

- req lives for the entire request lifecycle
    Every middleware & controller can access it
