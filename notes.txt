 - You do NOT clone when you already have a local project.
    You add the remote instead.
        Cloning is only for empty folders.
    If the remote repo on git has some files, then you have to pull them first.

- dotenv is loaded once, in the main file only then can called anywhere. npm install dotenv


Q - What is Router in Express ?

Ans - Imagine you put all routes in `index.js`:

        ```js
        app.get("/login", ...)
        app.post("/signup", ...)
        app.get("/courses", ...)
        app.post("/courses", ...)
        app.delete("/courses/:id", ...)
        ```

        ğŸ˜µ File becomes huge and messy.

        ğŸ‘‰ Router helps you split routes into small files.

        ---

        ## What is a router? (simple definition)

        > A router is like a mini Express app that handles routes for a specific feature.

        Think:

        * `app` â†’ whole application
        * `router` â†’ one section (users, courses, auth)

        ---

        ## Basic router example

        `routes/user.routes.js`

        ```js
        const express = require("express");
        const router = express.Router();

        router.post("/signup", (req, res) => {
        res.send("User signup");
        });

        router.post("/login", (req, res) => {
        res.send("User login");
        });

        module.exports = router;
        ```

        ---

        ## Using router in main file

        `index.js`

        ```js
        const express = require("express");
        const app = express();

        const userRouter = require("./routes/user.routes");

        app.use("/users", userRouter);

        app.listen(3000);
        ```

        ---

        ## How URLs are formed (important!)

        ```js
        app.use("/users", userRouter);
        ```

        Inside router:

        ```js
        router.post("/login", ...)
        ```

        â¡ Final URL:

        ```
        POST /users/login
        ```

        ---

        ## Why router is IMPORTANT (big reasons)

        1ï¸âƒ£ Clean code

        Each feature has its own file.

        2ï¸âƒ£ Easy to scale

        Add new routes without touching main file.

        3ï¸âƒ£ Team-friendly

        Multiple devs can work on different routers.

        4ï¸âƒ£ Middleware support

        You can add middleware to router only.

        ---

        ## Router with middleware (very useful)

        ```js
        router.use(authMiddleware);

        router.get("/profile", (req, res) => {
        res.send("Protected profile");
        });
        ```

        Only this router is protected ğŸ”

        ---

        ## Folder structure (recommended)

        ```
        src
        â”œâ”€â”€ index.js
        â”œâ”€â”€ routes
        â”‚   â”œâ”€â”€ user.routes.js
        â”‚   â”œâ”€â”€ course.routes.js
        â”‚   â””â”€â”€ admin.routes.js
        â”œâ”€â”€ controllers
        â””â”€â”€ models
        ```
        - It just connects URL â†’ logic.

Q - Can we use Zod input validation inside the mongoose schema itself ?

Ans - You do NOT use Zod inside database schemas (like Mongoose schemas).   

    Zod is used for request validation,
    Mongoose schema is used for database structure.

    They solve different problems.

    ---

    ## Think of it like this ğŸ§ 

    1ï¸âƒ£ Zod â†’ â€œIs the incoming data valid?â€

    * Runs before data reaches DB
    * Validates request body, params, query

    2ï¸âƒ£ Mongoose Schema â†’ â€œHow is data stored?â€

    * Defines MongoDB structure
    * Enforces DB-level rules

    ğŸ‘‰ They should not be mixed.

    ---

    ## Correct and CLEAN architecture âœ…

    ```
    request
    â†“
    Zod (validate input)
    â†“
    Controller
    â†“
    Mongoose Schema (save to DB)
    ```

    ---

    ## How to use Zod properly (BEST PRACTICE)

    Step 1: Create Zod schema (validation)

    ```js
    // validators/course.zod.js
    const { z } = require("zod");

    const createCourseSchema = z.object({
    title: z.string().min(3),
    price: z.number().positive(),
    description: z.string().optional(),
    });

    module.exports = { createCourseSchema };
    ```

    ---

    Step 2: Use Zod in route or controller

    ```js
    const { createCourseSchema } = require("../validators/course.zod");

    router.post("/courses", (req, res) => {
    const parsed = createCourseSchema.safeParse(req.body);

    if (!parsed.success) {
        return res.status(400).json(parsed.error);
    }

    // parsed.data is clean & validated
    });
    ```

    ---

    ## âŒ What you should NOT do

    ```js
    const courseSchema = new mongoose.Schema({
    title: z.string(),   // âŒ WRONG
    });
    ```

    Zod does not work here.

    ---

    ## Advanced (optional, for later)

    You can:

    * Share types between Zod & Mongoose
    * Generate TS types from Zod
    * Keep Zod as the single source of truth

    But for now â†’ keep them separate.

    ---

    ## Golden rule (remember this forever)

    > Zod validates requests
    > Mongoose defines database structure
